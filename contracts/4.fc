{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption and decryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
  character should go to the beginning. Return new text encoded in cell.
-}

;; (int) tlen (tuple t) asm "TLEN";
;; forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";

forall X -> int is_null (X x) asm "ISNULL";
forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";
forall X -> (tuple, (X)) pop_back (tuple t) asm "UNCONS";


() recv_internal() {
}

(cell) cipher(int shift, cell text) inline {
    slice ds = text.begin_parse();

    if (ds.slice_bits() < 32) {
        return text;
    }

    int prefix = ds~load_uint(32);
    if (prefix != 0) {
        return text;
    }

    if (ds.slice_data_empty?() | (shift == 0)) {
        return text;
    }

    if (ds.preload_uint(8) == 0xFF) {
        return text;
    }

    ;;     ds~skip_bits(32);

    tuple builders = null();

    builder cur_builder = begin_cell();
    cur_builder~store_uint(0, 32);

    int has_ref = 1;
    while (has_ref > 0) {
        while (~ ds.slice_data_empty?()) {
            int letter = ds~load_uint(8);

            int new_letter = ((letter >= 65) & (letter <= 90))
                    ? (letter + shift - 65) % 26 + 65
                    : ((letter >= 97) & (letter <= 122))
                    ? (letter + shift - 97) % 26 + 97
                    : letter;

            cur_builder~store_uint(new_letter, 8);

        }
        builders~push_back(cur_builder);

        if (ds.slice_refs_empty?()) {
            has_ref = 0;
        } else {
            ds = ds~load_ref().begin_parse();
            cur_builder = begin_cell();
        }
    }

    builder value = builders~pop_back();
    cell dc = value.end_cell();

    while (~ builders.is_null()) {
        value = builders~pop_back();
        dc = value.store_ref(dc).end_cell();
    }

    return dc;
}

;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
    shift %= 26;
    return cipher(shift, text);
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
    shift %= 26;
    return cipher(- shift, text);
}


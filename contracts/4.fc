{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption and decryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
  character should go to the beginning. Return new text encoded in cell.
-}

;;  64 - 1000000
;;  65 - 1000001
;;  90 - 1011010
;;  91 - 1011011


;;  96 - 1100000
;;  97 - 1100001
;; 122 - 1111010
;; 123 - 1111011

forall X -> int is_null (X x) asm "ISNULL";
forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";
forall X -> (tuple, (X)) pop_back (tuple t) asm "UNCONS";

(int, int) bit_refs(slice s) asm "SBITREFS";

cell pack_cells(tuple t) asm ""
        "<{"
        "UNCONS"
        "WHILE:<{ OVER ISNULL NOT }>DO<{ SWAP UNCONS ROT STBREFR }>"
        "ENDC"
        "}>CONT 1 1 CALLXARGS"
        ;




const n26 = 26;
const n32 = 32;

const n65 = 65;
const n97 = 97;

const n90 = 90;
const n122 = 122;


() recv_internal() {
}

(cell) cipher(int shift, cell text) inline {
    shift %= n26;

    slice ds = text.begin_parse();
    ds~skip_bits(n32);

    if (ds.slice_data_empty?() | (shift == 0)) {
        return text;
    }

    int shift_upper = shift - n65;
    int shift_low = shift - n97;

    tuple builders = null();

    builder cur_builder = begin_cell();
    cur_builder~store_uint(0, n32);

    (int bits, int refs) = (0, 0);

    do {
        (bits, refs) = bit_refs(ds);
        repeat (bits / 8) {
            int letter = ds~load_uint(8);

            int new_letter = ((letter >= n65) & (letter <= n90))
                    ? (letter + shift_upper) % n26 + n65
                    : ((letter >= n97) & (letter <= n122))
                    ? (letter + shift_low) % n26 + n97
                    : letter;

            cur_builder~store_uint(new_letter, 8);
        }
        builders~push_back(cur_builder);

        if (refs > 0) {
            ds = ds~load_ref().begin_parse();
            cur_builder = begin_cell();
        }

    } until (refs == 0);

    ;;     builder value = builders~pop_back();
    ;;     cell dc = value.end_cell();
    ;;
    ;;     while (~ builders.is_null()) {
    ;;         value = builders~pop_back();
    ;;         dc = value.store_ref(dc).end_cell();
    ;;     }

    cell dc = pack_cells(builders);

    return dc;
}

;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
    return cipher(shift, text);
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
    return cipher(- shift, text);
}


{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption and decryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
  character should go to the beginning. Return new text encoded in cell.
-}

;;  64 - 1000000
;;  65 - 1000001
;;  90 - 1011010
;;  91 - 1011011


;;  96 - 1100000
;;  97 - 1100001
;; 122 - 1111010
;; 123 - 1111011

forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";
forall X -> (tuple) to_tuple (X x) asm "NOP";

cell pack_cells(tuple t) asm ""
        "<{"
        "UNCONS"
        "WHILE:<{ OVER ISNULL NOT }>DO<{ SWAP UNCONS ROT STBREFR }>"
        "ENDC"
        "}>CONT 1 1 CALLXARGS"
        ;


const n26 = 26;
const n32 = 32;

const n65 = 65;
const n97 = 97;

const n90 = 90;
const n122 = 122;


() recv_internal() {
}

(cell) cipher(int shift, cell text) inline {
    shift %= n26;

    slice ds = text.begin_parse();
    ds~skip_bits(n32);

    if ((shift == 0) | ds.slice_data_empty?()) {
        return text;
    }

    int shift_upper = shift - n65;
    int shift_low = shift - n97;


    tuple  low_letters = empty_tuple();

    int  l = 97;
    repeat (n26) {
        low_letters~tpush((l + shift_low) % n26 + n97);
        l += 1;
    }

    ;;     tuple  low_letters = to_tuple([
    ;;             (97 + shift_low) % n26 + n97,
    ;;             (98 + shift_low) % n26 + n97,
    ;;             (99 + shift_low) % n26 + n97,
    ;;             (100 + shift_low) % n26 + n97,
    ;;             (101 + shift_low) % n26 + n97,
    ;;             (102 + shift_low) % n26 + n97,
    ;;             (103 + shift_low) % n26 + n97,
    ;;             (104 + shift_low) % n26 + n97,
    ;;             (105 + shift_low) % n26 + n97,
    ;;             (106 + shift_low) % n26 + n97,
    ;;             (107 + shift_low) % n26 + n97,
    ;;             (108 + shift_low) % n26 + n97,
    ;;             (109 + shift_low) % n26 + n97,
    ;;             (110 + shift_low) % n26 + n97,
    ;;             (111 + shift_low) % n26 + n97,
    ;;             (112 + shift_low) % n26 + n97,
    ;;             (113 + shift_low) % n26 + n97,
    ;;             (114 + shift_low) % n26 + n97,
    ;;             (115 + shift_low) % n26 + n97,
    ;;             (116 + shift_low) % n26 + n97,
    ;;             (117 + shift_low) % n26 + n97,
    ;;             (118 + shift_low) % n26 + n97,
    ;;             (119 + shift_low) % n26 + n97,
    ;;             (120 + shift_low) % n26 + n97,
    ;;             (121 + shift_low) % n26 + n97,
    ;;             (122 + shift_low) % n26 + n97
    ;;     ]);

    tuple builders = null();

    builder cur_builder = begin_cell();
    cur_builder~store_uint(0, n32);

    repeat (ds.slice_bits() / 8) {
        int letter = ds~load_uint(8);

        ((letter >= n97) & (letter <= n122))
                ? cur_builder~store_uint(low_letters.at(letter - n97), 8)
                : ((letter < n65) | (letter > n90))
                ? cur_builder~store_uint(letter, 8)
                : cur_builder~store_uint((letter + shift_upper) % n26 + n65, 8);

        ;;         ((letter >= n97) & (letter <= n122))
        ;;                 ? cur_builder~store_uint((letter + shift_low) % n26 + n97, 8)
        ;;                 : ((letter < n65) | (letter > n90))
        ;;                 ? cur_builder~store_uint(letter, 8)
        ;;                 : cur_builder~store_uint((letter + shift_upper) % n26 + n65, 8);

    }
    builders~push_back(cur_builder);

    repeat (text.cell_depth()) {
        ds = ds~load_ref().begin_parse();
        cur_builder = begin_cell();

        repeat (ds.slice_bits() / 8) {
            int letter = ds~load_uint(8);

            ((letter >= n97) & (letter <= n122))
                    ? cur_builder~store_uint(low_letters.at(letter - n97), 8)
                    : ((letter < n65) | (letter > n90))
                    ? cur_builder~store_uint(letter, 8)
                    : cur_builder~store_uint((letter + shift_upper) % n26 + n65, 8);

        }
        builders~push_back(cur_builder);
    }

    return pack_cells(builders);

}

;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
    return cipher(shift, text);
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
    return cipher(- shift, text);
}


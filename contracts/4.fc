{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption and decryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
  character should go to the beginning. Return new text encoded in cell.
-}

(int) tlen (tuple t) asm "TLEN";
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";

() recv_internal() {
}

(cell) cipher(int shift, cell text) inline {
    slice ds = text.begin_parse();

    ds~skip_bits(32);
    if (ds.slice_empty?()) {
        return text;
    }

    tuple builders = empty_tuple();

    builder cur_builder = begin_cell();
    cur_builder~store_uint(0, 32);

    int has_ref = 1;
    while (has_ref > 0) {
        while (~ ds.slice_data_empty?()) { ;; change to slice_bits()
            int letter = ds~load_uint(8);

            int new_letter = ((letter >= 65) & (letter <= 90))
                    ? (letter + shift - 65) % 26 + 65
                    : ((letter >= 97) & (letter <= 122))
                    ? (letter + shift - 97) % 26 + 97
                    : letter;

            cur_builder~store_uint(new_letter, 8);

        }
        builders~tpush(cur_builder);

        if (ds.slice_refs_empty?()) {
            has_ref = 0;
        } else {
            ds = ds~load_ref().begin_parse();
            cur_builder = begin_cell();
        }
    }

    builder value = builders~tpop();
    cell dc = value.end_cell();

    int count = builders.tlen();
    repeat (count) {
        value = builders~tpop();
        dc = value.store_ref(dc).end_cell();
    }

    return dc;
}

;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
    return cipher(shift, text);
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
    return cipher(- shift, text);
}


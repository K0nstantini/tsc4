{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption and decryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
  character should go to the beginning. Return new text encoded in cell.
-}

;;  64 - 1000000
;;  65 - 1000001
;;  90 - 1011010
;;  91 - 1011011


;;  96 - 1100000
;;  97 - 1100001
;; 122 - 1111010
;; 123 - 1111011

forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";

;; int get_letter(int shift_low, int shift_upper, int n) asm ""
;;         "<{"
;;         "DUP"
;;         "65 GEQINT"
;;         "IF:<{ DUP 90 LEQINT IF:<{ OVER ADD 26 INT MOD 65 ADDINT }>ELSE<{ DUP 97 GEQINT IF:<{ DUP 122 LEQINT IF:<{ ROT ADD 26 INT MOD 97 ADDINT }> }> }> }>"
;;         "}>CONT 3 1 CALLXARGS"
;;         ;

cell pack_cells(tuple t) asm ""
        "<{"
        "UNCONS"
        "WHILE:<{ OVER ISNULL NOT }>DO<{ SWAP UNCONS ROT STBREFR }>"
        "ENDC"
        "}>CONT 1 1 CALLXARGS"
        ;


const n26 = 26;
const n32 = 32;

const n65 = 65;
const n97 = 97;

const n90 = 90;
const n122 = 122;


() recv_internal() {
}

(cell) cipher(int shift, cell text) inline {
    shift %= n26;

    slice ds = text.begin_parse();
    ds~skip_bits(n32);

    if ((shift == 0) | ds.slice_data_empty?()) {
        return text;
    }

    int shift_upper = shift - n65;
    int shift_low = shift - n97;

    tuple builders = null();

    builder cur_builder = begin_cell();
    cur_builder~store_uint(0, n32);

    repeat (ds.slice_bits() / 8) {
        int letter = ds~load_uint(8);

        ((letter >= n97) & (letter <= n122))
                ? cur_builder~store_uint((letter + shift_low) % n26 + n97, 8)
                : ((letter < n65) | (letter > n90))
                ? cur_builder~store_uint(letter, 8)
                : cur_builder~store_uint((letter + shift_upper) % n26 + n65, 8);

    }
    builders~push_back(cur_builder);

    repeat (text.cell_depth()) {
        ds = ds~load_ref().begin_parse();
        cur_builder = begin_cell();

        repeat (ds.slice_bits() / 8) {
            int letter = ds~load_uint(8);

            ((letter >= n97) & (letter <= n122))
                    ? cur_builder~store_uint((letter + shift_low) % n26 + n97, 8)
                    : ((letter < n65) | (letter > n90))
                    ? cur_builder~store_uint(letter, 8)
                    : cur_builder~store_uint((letter + shift_upper) % n26 + n65, 8);

        }
        builders~push_back(cur_builder);
    }

    return pack_cells(builders);

}

;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
    return cipher(shift, text);
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
    return cipher(- shift, text);
}


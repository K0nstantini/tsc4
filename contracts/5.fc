{-
  TASK 5 - Fibonacci sequence
  Implement a function that generates the Fibonacci
  sequence from N to N+K terms (0<=N<=370; 0<=N+K<=371; 0<=K<=255).
  The first two terms of the Fibonacci sequence are F_0 = 0 and F_1 = 1,
  and the rest are defined as F_n = F_(n-1) + F_(n-2).
  The resulting Fibonacci sequence should be stored in a tuple.
  For example, a request with N = 1 and K = 3 should return a tuple [1, 1, 2],
  and a request with N = 201 and K = 4 should return a tuple
  [453973694165307953197296969697410619233826,
  734544867157818093234908902110449296423351,
  1188518561323126046432205871807859915657177,
  1923063428480944139667114773918309212080528]
-}


int tlen (tuple t) asm "TLEN";
forall X -> (tuple) to_tuple (X x) asm "NOP";

forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";
;; forall X -> (tuple, (X)) pop_back (tuple t) asm "UNCONS";

() recv_internal() {
}

int int_len(int n) inline {
    int len = 0;
    while (n) {
        n = n >> 1;
        len += 1;
    }
    return len;
}

(tuple) matrix_multiplier(tuple mA, tuple mB) inline {
    tuple result = empty_tuple();

    int a1 = mA.at(0).at(0) * mB.at(0).at(0) + mA.at(0).at(1) * mB.at(1).at(0);
    int a2 = mA.at(0).at(0) * mB.at(0).at(1) + mA.at(0).at(1) * mB.at(1).at(1);
    int a3 = mA.at(1).at(0) * mB.at(0).at(0) + mA.at(1).at(1) * mB.at(1).at(0);
    int a4 = mA.at(1).at(0) * mB.at(0).at(1) + mA.at(1).at(1) * mB.at(1).at(1);

    tuple row = empty_tuple();
    row~tpush(a1);
    row~tpush(a2);
    result~tpush(row);
    tuple row = empty_tuple();
    row~tpush(a3);
    row~tpush(a4);
    result~tpush(row);

    return result;
}

;; (int) fibo(int n, tuple result, tuple m) inline {
;;     slice ds = begin_cell()
;;             .store_uint(n, int_len(n))
;;             .end_cell()
;;             .begin_parse();
;;
;;     while (~ ds.slice_data_empty?()) {
;;         result = matrix_multiplier(result, result);
;;         int bit = ds~load_uint(1);
;;         if (bit) {
;;             result = matrix_multiplier(result, m);
;;         }
;;     }
;;     return result.at(1).at(0);
;; }

(tuple) pow(tuple m, int n, tuple id) {
    if (n == 0) {
        return id;
    }
    if (n == 1) {
        return m;
    }
    tuple y = pow(m, n / 2, id);
    y = matrix_multiplier(y, y);
    if (n % 2) {
        y = matrix_multiplier(m, y);
    }
    return y;
}

;; testable
(tuple) fibonacci_sequence (int n, int k) method_id {
    tuple result = empty_tuple();

    if (k == 0) {
        return result;
    }

    if (n + k < 100) {
        (int prev, int next) = (0, 1);

        int save_i = n - 1;
        int count = k + save_i;

        if (n == 0) {
            result~tpush(prev);
        }

        int i = 0;
        while (i < count) {
            int temp = next;
            if (i < count - 1) {
                next = prev + next;
            }
            prev = temp;
            if (i >= save_i) {
                result~tpush(prev);
            }
            i += 1;
        }
        return result;
    }

    tuple id = to_tuple([to_tuple([1, 0]), to_tuple([0, 1])]);
    tuple m = to_tuple([to_tuple([1, 1]), to_tuple([1, 0])]);

    int max = n + k - 1;
    int last = min(max, 369);
    while (n <= last) {
        result~tpush(pow(m, n, id).at(0).at(1));
        n += 1;
    }

    if (max == 370) {
        int pre1 = k >= 2 ? result.at(k - 2) : pow(m, 369, id).at(0).at(1);
        int pre2 = k >= 3 ? result.at(k - 3) : pow(m, 368, id).at(0).at(1);
        result~tpush(pre1 + pre2);
    }



    ;;
    ;;     tuple id = to_tuple([to_tuple([1, 0]), to_tuple([0, 1])]);
    ;;     tuple m = to_tuple([to_tuple([0, 1]), to_tuple([1, 1])]);
    ;;
    ;;     int max = n + k - 1;
    ;;     int last = min(max, 369);
    ;;     while (n <= last) {
    ;;         result~tpush(fibo(n, id, m));
    ;;         n += 1;
    ;;     }
    ;;
    ;;     if (max == 370) {
    ;;         int pre1 = k >= 2 ? result.at(k - 2) : fibo(369, id, m);
    ;;         int pre2 = k >= 3 ? result.at(k - 3) : fibo(368, id, m);
    ;;         result~tpush(pre1 + pre2);
    ;;     }

    return result;
}

